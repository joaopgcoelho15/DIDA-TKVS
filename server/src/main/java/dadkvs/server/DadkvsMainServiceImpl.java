package dadkvs.server;

/* these imported classes are generated by the contract */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Collections;

import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsServer;
import dadkvs.DadkvsServerServiceGrpc.DadkvsServerServiceStub;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.GenericResponseCollector;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    int timestamp;
    HashMap<Integer, dadkvs.DadkvsServerServiceGrpc.DadkvsServerServiceStub> stubs;
    int paxosRun;
    List<Integer> myStamp;

    public DadkvsMainServiceImpl(DadkvsServerState state, HashMap<Integer, dadkvs.DadkvsServerServiceGrpc.DadkvsServerServiceStub> stubs) {
        this.server_state = state;
        this.timestamp = 0;
        this.stubs = stubs;
        paxosRun = 1;
        myStamp = new ArrayList<>(1000);
        myStamp.addAll(java.util.Collections.nCopies(1000, server_state.my_id));
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
        // for debug purposes
        System.out.println("Receiving read request:" + request);
        WaitForUnfreeze();
        int reqId = request.getReqid();
        int key = request.getKey();
        VersionedValue vv = this.server_state.store.read(key);

        DadkvsMain.ReadReply response = DadkvsMain.ReadReply.newBuilder()
                .setReqid(reqId).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {
        // for debug purposes
        System.out.println("Receiving commit request:" + request);

        WaitForUnfreeze();

        int reqId = request.getReqid();
        boolean reconfig = false;

        if(request.getWritekey() == 0){
            reconfig = true;
        } 

        if (server_state.proposedValue.contains(reqId)) {
            System.out.println("Value already commited\n");
            return;
        }

        if (!server_state.idQueue.isEmpty()) {
            if (reqId == server_state.idQueue.peekFirst()) {
                //TODO: O próximo é o 10, mas o 11 pode já estar na fila, logo temos de verificar qual é o currentPaxosRun
                commitValue(request, responseObserver, reqId);
                server_state.idQueue.removeFirst();
            }
        } else if (server_state.i_am_leader && !server_state.onlyLearners.contains(server_state.my_id)) {
            //There is already a value commited to this paxosRun
            if (server_state.proposedValue.get(paxosRun) != -1) {
                paxosRun += nextPaxosRun();
            }
            server_state.addPendingRequest(request, responseObserver);
            innitPaxos(stubs, reqId, reconfig);
        } else {
            server_state.addPendingRequest(request, responseObserver);
        }
    }

    public void innitPaxos(HashMap<Integer, DadkvsServerServiceStub> stubs, int reqid, boolean reconfig) {
        System.out.println("Paxos Run: " + paxosRun + " Value: " + reqid);

        DadkvsServer.PhaseOneRequest proposeRequest = DadkvsServer.PhaseOneRequest.newBuilder().setPhase1Timestamp(myStamp.get(paxosRun)).setPhase1Index(paxosRun).setPhase1Config(server_state.currentConfig).build();

        ArrayList<DadkvsServer.PhaseOneReply> promises = new ArrayList<>();
        GenericResponseCollector<DadkvsServer.PhaseOneReply> promises_collector = new GenericResponseCollector<>(promises, 2);

        for (int i = 0; i < 5; i++) {
            //Send the PROPOSE message to all the acceptors
            if (server_state.onlyLearners.contains(i) || i == server_state.my_id) {
                continue;
            }
            CollectorStreamObserver<DadkvsServer.PhaseOneReply> p1_observer = new CollectorStreamObserver<>(promises_collector);
            stubs.get(i).phaseone(proposeRequest, p1_observer);
        }
        promises_collector.waitForTarget(2);

        int acceptedPrepares = 0;
        int acceptedValue = -1;
        int newValue = -1;
        int highestID = -1;
        boolean stop = false;

        if (promises.size() >= 2) {

            for (DadkvsServer.PhaseOneReply promise : promises) {
                //If the PREPARE was accepted
                if (promise.getPhase1Accepted()) {
                    acceptedPrepares++;
                    acceptedValue = promise.getPhase1Value();

                    if(promise.getStop()){
                        stop = true;
                    }

                    //If there was already a commited value this leader adopts this value
                    if (acceptedValue != -1 && promise.getPhase1Timestamp() > highestID) {
                        newValue = acceptedValue;
                        highestID = promise.getPhase1Timestamp();
                    }
                }
            }
            //If majority is accepted go to phase 2
            if (acceptedPrepares > 0) {
                //If another leader has already proposed a value
                if (newValue != -1) {
                    System.out.println("Adopting value " + newValue);
                    proposerPhase2(newValue, stubs, stop);
                    if (reqid != newValue) {
                        innitPaxos(stubs, reqid, reconfig);
                    }
                } else {
                    System.out.println("No value to adopt, proposing new value");
                    proposerPhase2(reqid, stubs, reconfig);
                }
            }
            //If the prepare request was not accepted, try again with a new timestamp
            else {
                myStamp.set(paxosRun, myStamp.get(paxosRun) + 3);
                System.out.println("Prepare not accepted, trying again with new timestamp");
                innitPaxos(stubs, reqid, reconfig);
            }
        } else
            System.out.println("Panic...error preparing");
    }

    public void proposerPhase2(int value, HashMap<Integer, DadkvsServerServiceStub> stubs, boolean reconfig) {
        System.out.println("Starting phase 2");
        DadkvsServer.PhaseTwoRequest proposeRequest = DadkvsServer.PhaseTwoRequest.newBuilder().setPhase2Timestamp(myStamp.get(paxosRun)).setPhase2Value(value).setPhase2Index(paxosRun).setPhase2Config(server_state.currentConfig).setStop(reconfig).build();

        ArrayList<DadkvsServer.PhaseTwoReply> acceptRequests = new ArrayList<>();
        GenericResponseCollector<DadkvsServer.PhaseTwoReply> acceptRequests_collector = new GenericResponseCollector<>(acceptRequests, 4);

        for (int i = 0; i < 5; i++) {
            //Send the ACCEPT-REQUEST message to all the acceptors
            if (server_state.onlyLearners.contains(i) || i == server_state.my_id) {
                continue;
            }
            CollectorStreamObserver<DadkvsServer.PhaseTwoReply> p2_observer = new CollectorStreamObserver<>(acceptRequests_collector);
            stubs.get(i).phasetwo(proposeRequest, p2_observer);
        }
        acceptRequests_collector.waitForTarget(2);

        int acceptedPrepares = 0;

        if (acceptRequests.size() >= 2) {

            for (DadkvsServer.PhaseTwoReply acceptReq : acceptRequests) {
                //If the REQUEST-ACCEPT was accepted
                if (acceptReq.getPhase2Accepted()) {
                    acceptedPrepares++;
                }
            }
            //If majority is accepted a new consensus is reached
            if (acceptedPrepares >= 2) {
                System.out.println("Consensus reached for run " + paxosRun);

                if (!server_state.idQueue.contains(value) && !server_state.isCommited.get(paxosRun)) {
                    server_state.idQueue.addLast(value);
                }

                DadkvsMain.CommitRequest pendingRequest = searchRequest(value);
                if (pendingRequest != null && server_state.idQueue.peekFirst() != null && value == server_state.idQueue.peekFirst()) {
                    if (checkPrevRuns(paxosRun)) {
                        System.out.println("There are previous runs that are not finished\n");
                        server_state.futureValues.put(paxosRun, value);
                    } else {
                        //Commit all the values that reached consesus after but have a lower paxosRun
                        commitValue(pendingRequest, server_state.pendingRequests.remove(pendingRequest), value);
                        server_state.idQueue.removeFirst();
                        server_state.isCommited.set(paxosRun, true);
                        if (!server_state.futureValues.isEmpty()) {
                            commitFutureValues();
                        }
                    }
                }

                paxosRun++;
            } else {
                myStamp.set(paxosRun, myStamp.get(paxosRun) + 3);
                System.out.println("REQUEST-ACCEPT not accepted, trying again with new timestamp\n");
                innitPaxos(stubs, value, reconfig);
            }
        } else
            System.out.println("Panic...error commiting");
    }

    public int nextPaxosRun() {
        int currPaxosRun = 0;
        while (server_state.proposedValue.get(currPaxosRun + paxosRun) != -1) {
            currPaxosRun++;
        }

        return currPaxosRun;
    }

    public DadkvsMain.CommitRequest searchRequest(int reqId) {
        if (server_state.pendingRequests.isEmpty()) {
            return null;
        }
        for (DadkvsMain.CommitRequest pendingRequest : server_state.pendingRequests.keySet()) {
            //If the incoming request is stored and
            Integer nextReq = server_state.idQueue.peekFirst();
            if (pendingRequest.getReqid() == reqId && nextReq != null && reqId == nextReq) {
                return pendingRequest;
            }
        }
        return null;
    }

    public void commitValue(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver, int reqid) {
        System.out.println("Commiting request: " + reqid);

        int key1 = request.getKey1();
        int version1 = request.getVersion1();
        int key2 = request.getKey2();
        int version2 = request.getVersion2();
        int writeKey = request.getWritekey();
        int writeVal = request.getWriteval();

        //If the commit is for the key 0, it means it is a reconfiguration
        if (writeKey == 0) {
            reConfig(writeVal);
            System.out.println("Incoming reconfiguration: From " + (writeVal - 1) + " to " + writeVal + "\n");
        }

        // for debug purposes
        System.out.println("reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 " + version2 + " wk " + writeKey + " writeval " + writeVal);

        this.timestamp++;
        TransactionRecord txRecord = new TransactionRecord(key1, version1, key2, version2, writeKey, writeVal, this.timestamp);
        boolean result = this.server_state.store.commit(txRecord);

        // for debug purposes
        System.out.println("Result is ready for request with reqid " + reqid);

        DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                .setReqid(reqid).setAck(result).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    public void reConfig(int config) {

        server_state.currentConfig = config;
        server_state.onlyLearners.clear();

        switch (config) {
            case 0 -> server_state.onlyLearners.addAll(List.of(3, 4));
            case 1 -> server_state.onlyLearners.addAll(List.of(4, 0));
            case 2 -> server_state.onlyLearners.addAll(List.of(0, 1));
            default -> {
            }
        }

    }

    public boolean checkPrevRuns(int paxosRun) {

        for (int i = 1; i < paxosRun; i++) {
            //If we find a run of paxos that is not finished, we return true
            if (!server_state.isCommited.get(i)) {
                return true;
            }
        }
        return false;
    }

    public void commitFutureValues() {
        int value;
        DadkvsMain.CommitRequest pendingRequest;

        // Get the keys from the map and sort them
        List<Integer> sortedKeys = new ArrayList<>(server_state.futureValues.keySet());
        Collections.sort(sortedKeys);

        for (Integer key : sortedKeys) {
            value = server_state.futureValues.get(key);
            pendingRequest = searchRequest(value);

            commitValue(pendingRequest, server_state.pendingRequests.remove(pendingRequest), value);
            server_state.idQueue.remove(value);
            server_state.isCommited.set(key, true);
            server_state.futureValues.remove(key);
        }
    }

    private void WaitForUnfreeze() {
        server_state.lock.lock();
        try {
            while (server_state.isFrozen) {
                server_state.freezeCondition.await();
            }
            if (server_state.slowMode) {
                Thread.sleep(server_state.sleepDelay);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            server_state.lock.unlock();
        }
    }
}
