
package dadkvs.server;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsServer;
import dadkvs.DadkvsServerServiceGrpc;

import dadkvs.util.GenericResponseCollector;
import dadkvs.util.CollectorStreamObserver;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

public class DadkvsPaxosServiceImpl extends DadkvsServerServiceGrpc.DadkvsServerServiceImplBase {


    DadkvsServerState server_state;
    int leaderStamp;
    int proposedValue;


    public DadkvsPaxosServiceImpl(DadkvsServerState state) {
        this.server_state = state;
        leaderStamp = -1;
        proposedValue = -1;
    }


    @Override
    public void phaseone(DadkvsServer.PhaseOneRequest request, StreamObserver<DadkvsServer.PhaseOneReply> responseObserver) {
        // for debug purposes
        System.out.println("Receive phase1 request: " + request);

        int currentStamp = request.getPhase1Timestamp();

        DadkvsServer.PhaseOneReply response;

        //If this proposer has an ID higher then any ID I have promised
        if(currentStamp > leaderStamp){
            //If a value has already been accepted previously
            if(proposedValue >= 0){
                //Send PROMISE IDp accepted IDa, value
                response = DadkvsServer.PhaseOneReply.newBuilder()
                .setPhase1Accepted(true).setPhase1Timestamp(leaderStamp).setPhase1Value(proposedValue).build();
            }
            else{
                //Send PROMISE IDp
                response = DadkvsServer.PhaseOneReply.newBuilder()
                .setPhase1Accepted(true).setPhase1Timestamp(-1).setPhase1Value(-1).build();
            }
            leaderStamp = currentStamp;
        }
        else{
            //Ignore the request
            response = DadkvsServer.PhaseOneReply.newBuilder()
                .setPhase1Accepted(false).build();
        }

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void phasetwo(DadkvsServer.PhaseTwoRequest request, StreamObserver<DadkvsServer.PhaseTwoReply> responseObserver) {
        // for debug purposes
        System.out.println("Receive phase two request: " + request);

        int currentStamp = request.getPhase2Timestamp();

        DadkvsServer.PhaseTwoReply response;

        if(currentStamp > leaderStamp){
            leaderStamp = currentStamp;
            //Reply ACCEPT IDp, value
            response = DadkvsServer.PhaseTwoReply.newBuilder()
                .setPhase2Accepted(true).build();
            //Also broadcast to all learners

        }
        else{
            //Ignore the request
            response = DadkvsServer.PhaseTwoReply.newBuilder()
                .setPhase2Accepted(false).build();
        }

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void learn(DadkvsServer.LearnRequest request, StreamObserver<DadkvsServer.LearnReply> responseObserver) {
        // for debug purposes
        System.out.println("Receive learn request: " + request);

    }

    public void innitPaxos(List<DadkvsServerServiceGrpc.DadkvsServerServiceStub> stubs){
        DadkvsServer.PhaseOneRequest proposeRequest = DadkvsServer.PhaseOneRequest.newBuilder().setPhase1Timestamp(server_state.paxosStamp).build();
        ListIterator<DadkvsServerServiceGrpc.DadkvsServerServiceStub> stubIterator = stubs.listIterator();

        ArrayList<DadkvsServer.PhaseOneReply> promises = new ArrayList<DadkvsServer.PhaseOneReply>();
        GenericResponseCollector<DadkvsServer.PhaseOneReply> promises_collector = new GenericResponseCollector<DadkvsServer.PhaseOneReply>(promises, 4);

        while (stubIterator.hasNext()) {
            CollectorStreamObserver<DadkvsServer.PhaseOneReply> broad_observer = new CollectorStreamObserver<DadkvsServer.PhaseOneReply>(promises_collector);
            stubIterator.next().phaseone(proposeRequest, broad_observer);
        }
        try {
            promises_collector.wait(100);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        int acceptedPrepares = 0;
        int acceptedValue = -1;
        int newValue = -1;

        if (promises.size() >= 5) {

            for (DadkvsServer.PhaseOneReply promise : promises) {
                //If the PREPARE was accepted
                if (promise.getPhase1Accepted()) {
                    acceptedPrepares++;
                    acceptedValue = promise.getPhase1Value();
                    //If there was already a commited value this leader adopts this value
                    if (acceptedValue != -1) {
                        newValue = acceptedValue;
                    }
                }
            }
            //If majority is accepted go to phase 2
            if (acceptedPrepares > 2) {
                //Code for phase 2
                proposerPhase2();
            }
        }
        else
            System.out.println("Panic...error commiting");
    }

    public void proposerPhase2(){

    }

}
